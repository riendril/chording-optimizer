# File Formats Guide

This guide explains the different file types used by the Chording Optimizer and how to work with them.

## Corpus Files

Corpus files contain the text data that the optimizer analyzes to identify frequently used patterns.

### Location

- **Directory**: `data/corpuses/`
- **Format**: Plain text files (`.txt`)
- **Encoding**: UTF-8

### Purpose

Corpus files represent your typical typing patterns. The optimizer analyzes this text to:

- Identify frequently used words and phrases
- Calculate character and token frequencies
- Determine optimal segmentation patterns
- Score potential chord candidates

### Provided Corpus Files

- **`brown.txt`**: Sample from the Brown Corpus (general English text)
- **`fox.txt`**: Simple test corpus with "The quick brown fox..." text

### Creating Custom Corpus Files

1. **Collect Representative Text**: Gather text samples that represent your typical typing:

   - Email drafts and sent messages
   - Documents you've written
   - Code files (if you program)
   - Chat logs or forum posts

2. **Prepare the Text**:

   - Combine into a single text file
   - Remove sensitive or personal information
   - Ensure UTF-8 encoding
   - Aim for 50,000+ characters for good analysis

3. **Save and Configure**:
   - Save as `.txt` file in `data/corpuses/`
   - Update `active_corpus_file` in `data/config.yaml`

### Corpus Generation

The optimizer can also generate corpus files automatically from various online sources. See the `corpus_generation` section in `config.yaml` for available options.

## Token Files

Token files contain collections of text tokens with their analysis data and scoring information.

### Location

- **Directory**: `data/tokens/`
- **Format**: JSON files (`.json`)
- **Generated by**: Token extraction pipeline stage

### Structure

```json
{
  "name": "corpus_name_tokens_1000",
  "orderedByFrequency": true,
  "tokens": [
    {
      "lower": "the",
      "character_length": 3,
      "subtoken_length": 1,
      "token_type": "FULL_WORD",
      "text_count": 1234,
      "usage_count": 1234,
      "rank": 1,
      "usage_cost": 2.5,
      "replacement_score": 0.85,
      "selected": true,
      "best_current_combination": ["the"],
      "adjacent_tokens": {...}
    }
  ]
}
```

### Key Fields

- **`lower`**: The token text in lowercase
- **`token_type`**: Classification (SINGLE_CHARACTER, FULL_WORD, etc.)
- **`text_count`**: How many times this token appears in the corpus
- **`usage_cost`**: Cost of typing this token with current method
- **`replacement_score`**: Benefit score for assigning this token to a chord
- **`selected`**: Whether this token was selected for chord assignment
- **`adjacent_tokens`**: Context information about surrounding tokens

### Using Token Files

- **Generated Automatically**: Created by running the `token_extraction` pipeline stage
- **Pre-selection**: You can create custom token files to pre-select specific tokens
- **Analysis**: Review token files to understand what the optimizer identified

## Keyboard Layout Files

Keyboard layout files define the physical keyboard configuration and ergonomic properties.

### Location

- **Directory**: `data/keyLayouts/`
- **Format**: YAML files (`.yaml`)

### Provided Layouts

- **`QWERTY_Traditional_US-ANSI.yaml`**: Standard US QWERTY layout
- **`Colemak-DH_Matrix.yaml`**: Colemak-DH layout optimized for matrix keyboards
- **`Riendril-QWERTZ_Traditional_DE-ISO.yaml`**: German QWERTZ layout
- **`Riendril-QWERTZ_Ergonomic_DE-ISO.yaml`**: Ergonomic German layout
- **`Nordrassil_Ergonomic.yaml`**: Custom ergonomic layout

### Structure

```yaml
name: "Layout Name"
type: "traditional"
description: "Layout description"

# Key positions (row, column) from home position
positions:
  a: [0, 0] # Home row, leftmost
  s: [0, 1] # Home row, second from left
  # ... more keys

# Finger assignments
fingers:
  a: "L_PINKY"
  s: "L_RING"
  # ... more assignments

# Usage cost matrix (lower = more comfortable)
usage_cost:
  a: 1.0 # Home row keys are most comfortable
  q: 2.5 # Top row requires more effort
  z: 3.0 # Bottom row is least comfortable
  unknown: 5.0 # Fallback for unmapped keys
```

### Key Components

#### Positions

- **Coordinates**: `[row, column]` relative to home position
- **Home Row**: Row 0 (most comfortable)
- **Other Rows**: Positive/negative values for rows above/below

#### Finger Assignments

- **Available Fingers**: `L_PINKY`, `L_RING`, `L_MIDDLE`, `L_INDEX`, `L_THUMB`, `R_THUMB`, `R_INDEX`, `R_MIDDLE`, `R_RING`, `R_PINKY`
- **One Finger Per Key**: Each key must be assigned to exactly one finger

#### Usage Cost Matrix

- **Lower Values**: More comfortable/efficient keys
- **Higher Values**: Less comfortable keys requiring more effort
- **Required Entry**: `unknown` key for unmapped characters

### Creating Custom Layouts

1. **Measure Your Keyboard**: Determine the physical layout and key positions
2. **Assign Fingers**: Map each key to the finger that naturally presses it
3. **Calculate Costs**: Assign usage costs based on comfort and efficiency
4. **Test and Refine**: Use the layout and adjust costs based on experience

### Selecting a Layout

Update the `active_layout_file` setting in `data/config.yaml` to use a different layout:

```yaml
active_layout_file: "your_layout.yaml"
```

## Configuration Parameters

All other configuration options are documented directly in `data/config.yaml` with detailed comments explaining each parameter's purpose and valid values. This includes:

- Pipeline stage selection
- Algorithm parameters
- Optimization weights
- Debug and benchmarking options
- Corpus generation settings

Refer to the config file itself for the most up-to-date parameter documentation.
